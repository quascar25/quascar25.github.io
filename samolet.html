<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Каркас Самолёта</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: monospace;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #0f0;
            font-size: 12px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 30px;
            left: 10px;
            color: #aaa;
            font-size: 11px;
            z-index: 100;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="info">3D Каркас Самолёта с профилем NACA 0012</div>
    <div id="controls">Используйте мышь для вращения</div>
    
    <canvas id="airplaneCanvas"></canvas>
    
    <script>
        const canvas = document.getElementById('airplaneCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Параметры камеры и проекции
        let camera = {
            x: 0, y: 0, z: 15,
            angleX: 0.3,
            angleY: 0.5
        };
        
        // Функция проекции 3D -> 2D
        function project(x, y, z) {
            // Поворот вокруг осей
            const cosX = Math.cos(camera.angleX);
            const sinX = Math.sin(camera.angleX);
            const cosY = Math.cos(camera.angleY);
            const sinY = Math.sin(camera.angleY);
            
            // Вращение вокруг Y
            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;
            
            // Вращение вокруг X
            let y1 = y * cosX - z1 * sinX;
            z1 = y * sinX + z1 * cosX;
            
            // Перспективная проекция
            const scale = 500 / (z1 + camera.z);
            const screenX = canvas.width / 2 + x1 * scale;
            const screenY = canvas.height / 2 - y1 * scale;
            
            return { x: screenX, y: screenY, depth: z1 };
        }
        
        // Функция профиля NACA 0012
        function naca0012Thickness(x) {
            const t = 0.12;
            return 5 * t * (
                0.2969 * Math.sqrt(x) - 
                0.1260 * x - 
                0.3516 * Math.pow(x, 2) + 
                0.2843 * Math.pow(x, 3) - 
                0.1015 * Math.pow(x, 4)
            );
        }
        
        // Генерация точек крыла
        function generateWingPoints() {
            const points = [];
            const steps = 10;
            
            // Два профиля (передний и задний по Z)
            for (let z = -2; z <= 2; z += 4) {
                for (let i = 0; i <= steps; i++) {
                    const x = i / steps;
                    const yUpper = naca0012Thickness(x);
                    const yLower = -naca0012Thickness(x);
                    
                    // Масштабируем крыло
                    const scale = 8;
                    points.push({
                        x: x * scale - scale/2,
                        y: yUpper * scale,
                        z: z,
                        type: 'upper'
                    });
                    
                    if (i > 0 && i < steps) {
                        points.push({
                            x: x * scale - scale/2,
                            y: yLower * scale,
                            z: z,
                            type: 'lower'
                        });
                    }
                }
            }
            
            return points;
        }
        
        // Генерация точек фюзеляжа
        function generateFuselagePoints() {
            const points = [];
            const length = 12;
            const radius = 1.2;
            const segments = 8;
            
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                // Нос и хвост
                points.push({ x: -length/2, y, z: x, type: 'fuselage' });
                points.push({ x: length/2, y: y * 0.4, z: x * 0.4, type: 'fuselage' });
            }
            
            return points;
        }
        
        // Генерация точек хвоста
        function generateTailPoints() {
            return [
                // Горизонтальный стабилизатор
                { x: 6, y: 0.5, z: -3, type: 'tail' },
                { x: 6, y: 0.5, z: 3, type: 'tail' },
                { x: 7, y: 0.5, z: -3, type: 'tail' },
                { x: 7, y: 0.5, z: 3, type: 'tail' },
                
                // Вертикальный стабилизатор
                { x: 6, y: 0.5, z: 0, type: 'tail' },
                { x: 6, y: 2.5, z: 0, type: 'tail' },
                { x: 7, y: 1.5, z: 0, type: 'tail' }
            ];
        }
        
        // Все точки самолета
        const allPoints = [
            ...generateWingPoints(),
            ...generateFuselagePoints(),
            ...generateTailPoints()
        ];
        
        // Соединения для отрисовки линий
        const connections = [];
        
        // Соединения для крыла
        const wingPoints = generateWingPoints();
        for (let i = 0; i < wingPoints.length - 1; i++) {
            if (wingPoints[i].z === wingPoints[i+1]?.z) {
                connections.push([i, i+1]);
            }
        }
        
        // Соединения между передним и задним профилем
        const frontProfile = wingPoints.filter(p => p.z === -2);
        const backProfile = wingPoints.filter(p => p.z === 2);
        for (let i = 0; i < Math.min(frontProfile.length, backProfile.length); i++) {
            connections.push([
                allPoints.indexOf(frontProfile[i]),
                allPoints.indexOf(backProfile[i])
            ]);
        }
        
        // Отрисовка
        function draw() {
            // Очистка
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Проекция всех точек
            const projectedPoints = allPoints.map(p => ({
                ...project(p.x, p.y, p.z),
                type: p.type
            }));
            
            // Рисуем соединения
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 1;
            
            for (const [i, j] of connections) {
                const p1 = projectedPoints[i];
                const p2 = projectedPoints[j];
                
                if (p1 && p2) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
            
            // Рисуем точки разными цветами
            projectedPoints.forEach((p, index) => {
                if (!p) return;
                
                let color;
                switch(allPoints[index].type) {
                    case 'upper': color = '#00aaff'; break;
                    case 'lower': color = '#0088cc'; break;
                    case 'fuselage': color = '#aaaaaa'; break;
                    case 'tail': color = '#00ff00'; break;
                    default: color = '#ffffff';
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Подписи для ключевых точек
                if (index === 0 || index === 10 || index === wingPoints.length) {
                    ctx.fillStyle = '#aaa';
                    ctx.font = '10px monospace';
                    ctx.fillText(`(${allPoints[index].x.toFixed(1)}, ${allPoints[index].y.toFixed(1)}, ${allPoints[index].z.toFixed(1)})`, p.x + 5, p.y - 5);
                }
            });
            
            // Информация о профиле
            ctx.fillStyle = '#0f0';
            ctx.font = '12px monospace';
            ctx.fillText(`Профиль NACA 0012 | Макс. толщина: x=0.3, y=0.06`, 20, canvas.height - 40);
            ctx.fillText(`Камера: X=${camera.angleX.toFixed(2)}, Y=${camera.angleY.toFixed(2)}`, 20, canvas.height - 20);
        }
        
        // Управление мышью
        let isDragging = false;
        let lastX = 0, lastY = 0;
        
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;
            
            camera.angleY += dx * 0.01;
            camera.angleX += dy * 0.01;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            draw();
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
            camera.z += e.deltaY * 0.1;
            camera.z = Math.max(5, Math.min(50, camera.z));
            draw();
        });
        
        // Адаптация к размеру окна
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        });
        
        // Первая отрисовка
        draw();
        
        // Автоматическое вращение
        let autoRotate = true;
        function animate() {
            if (autoRotate && !isDragging) {
                camera.angleY += 0.005;
                draw();
            }
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Переключение автовращения по клику
        canvas.addEventListener('click', () => {
            autoRotate = !autoRotate;
            document.getElementById('controls').textContent = 
                autoRotate ? 'Автовращение ВКЛ | Клик для остановки' : 'Автовращение ВЫКЛ | Клик для запуска';
        });
    </script>
</body>
</html>
