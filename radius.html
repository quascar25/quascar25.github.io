<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGI Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .header {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            opacity: 0;
            animation: headerAppear 1s 4s forwards;
            z-index: 100;
        }

        .header-noagi {
            font-size: 36px;
            font-weight: bold;
            color: #c0c0c0;
            opacity: 0.7;
        }

        @keyframes headerAppear {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }

        .app-content {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            opacity: 0;
            animation: contentAppear 1s 4.5s forwards;
            z-index: 100;
        }

        @keyframes contentAppear {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <canvas id="canvas3d"></canvas>
    
    <!-- Финальный заголовок -->
    <div class="header">
        <div class="header-noagi">AGI</div>
    </div>
    
    <!-- Контент приложения -->
    <div class="app-content">
        <h2>Приложение AGI</h2>
        <p>Контент вашего приложения</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Создание звездного неба
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const starsCount = 200;
            
            for (let i = 0; i < starsCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const size = Math.random() * 2 + 1;
                const delay = Math.random() * 5;
                
                star.style.left = `${x}%`;
                star.style.top = `${y}%`;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.animationDelay = `${delay}s`;
                
                starsContainer.appendChild(star);
            }
        }

        // Парсинг OBJ данных
        const objData = `
        # Ваш OBJ файл здесь (вставьте полное содержимое)
        v  262.140961 0.000000 133.928848
        v  263.764221 0.000000 129.445618
        // ... остальные вершины
        `;

        function parseOBJ(text) {
            const vertices = [];
            const faces = [];
            
            const lines = text.split('\n');
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    vertices.push([
                        parseFloat(parts[1]),
                        parseFloat(parts[2]), 
                        parseFloat(parts[3])
                    ]);
                } else if (parts[0] === 'f') {
                    const face = [];
                    for (let i = 1; i < parts.length; i++) {
                        const indices = parts[i].split('/');
                        face.push(parseInt(indices[0]) - 1);
                    }
                    faces.push(face);
                }
            }
            
            return { vertices, faces };
        }

        // Создание 3D сцены
        let scene, camera, renderer, skullMesh, noagiMesh;
        let animationMixer;

        function init() {
            // Сцена
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Камера
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera.position.z = 5;

            // Рендерер
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas3d'),
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Освещение
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xc0c0c0, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Создание мешей
            createMeshes();
            
            // Запуск анимации
            startAnimation();

            // Обработчик изменения размера
            window.addEventListener('resize', onWindowResize);
        }

        function createMeshes() {
            // Создание черепа (упрощенная геометрия)
            const skullGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const skullMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xc0c0c0,
                shininess: 100,
                transparent: true,
                opacity: 1
            });
            skullMesh = new THREE.Mesh(skullGeometry, skullMaterial);
            skullMesh.scale.set(0, 0, 0);
            scene.add(skullMesh);

            // Создание надписи AGI из OBJ данных
            const { vertices, faces } = parseOBJ(objData);
            
            // Создание геометрии из OBJ данных
            const noagiGeometry = new THREE.BufferGeometry();
            const positionArray = new Float32Array(vertices.length * 3);
            
            for (let i = 0; i < vertices.length; i++) {
                positionArray[i * 3] = vertices[i][0] / 100 - 2.8;
                positionArray[i * 3 + 1] = vertices[i][2] / 100 - 1.3;
                positionArray[i * 3 + 2] = vertices[i][1];
            }
            
            noagiGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            
            // Создание индексов для faces
            const indices = [];
            for (const face of faces) {
                for (let i = 1; i < face.length - 1; i++) {
                    indices.push(face[0], face[i], face[i + 1]);
                }
            }
            noagiGeometry.setIndex(indices);
            noagiGeometry.computeVertexNormals();

            const noagiMaterial = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                shininess: 50,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });

            noagiMesh = new THREE.Mesh(noagiGeometry, noagiMaterial);
            noagiMesh.scale.set(0.001, 0.001, 0.001);
            scene.add(noagiMesh);
        }

        function startAnimation() {
            const timeline = [
                // 0-0.5s: Появление объектов
                { time: 0, skullScale: 0, noagiScale: 0.05, skullOpacity: 0, noagiOpacity: 0 },
                { time: 0.5, skullScale: 1, noagiScale: 0.05, skullOpacity: 1, noagiOpacity: 0.7 },
                
                // 0.5-3.5s: Масштабирование
                { time: 3.5, skullScale: 1.2, noagiScale: 0.0023, skullOpacity: 1, noagiOpacity: 0.7 },
                
                // 3.5-4s: Исчезновение черепа и движение надписи
                { time: 4, skullScale: 1.2, noagiScale: 0.0023, skullOpacity: 0, noagiOpacity: 0.7, noagiPosition: -3 }
            ];

            let startTime = Date.now();

            function animate() {
                const currentTime = (Date.now() - startTime) / 1000;
                
                // Находим текущий и следующий ключевые кадры
                let currentFrame = timeline[0];
                let nextFrame = timeline[1];
                
                for (let i = 0; i < timeline.length - 1; i++) {
                    if (currentTime >= timeline[i].time && currentTime <= timeline[i + 1].time) {
                        currentFrame = timeline[i];
                        nextFrame = timeline[i + 1];
                        break;
                    }
                }
                
                // Интерполяция между кадрами
                const progress = (currentTime - currentFrame.time) / (nextFrame.time - currentFrame.time);
                const clampedProgress = Math.max(0, Math.min(1, progress));
                
                // Применение анимации к черепу
                if (skullMesh) {
                    const skullScale = currentFrame.skullScale + (nextFrame.skullScale - currentFrame.skullScale) * clampedProgress;
                    skullMesh.scale.set(skullScale, skullScale, skullScale);
                    
                    const skullOpacity = currentFrame.skullOpacity + (nextFrame.skullOpacity - currentFrame.skullOpacity) * clampedProgress;
                    skullMesh.material.opacity = skullOpacity;
                }
                
                // Применение анимации к надписи
                if (noagiMesh) {
                    const noagiScale = currentFrame.noagiScale + (nextFrame.noagiScale - currentFrame.noagiScale) * clampedProgress;
                    noagiMesh.scale.set(noagiScale, noagiScale, noagiScale);
                    
                    const noagiOpacity = currentFrame.noagiOpacity + (nextFrame.noagiOpacity - currentFrame.noagiOpacity) * clampedProgress;
                    noagiMesh.material.opacity = noagiOpacity;
                    
                    if (nextFrame.noagiPosition !== undefined) {
                        const targetY = currentFrame.noagiPosition !== undefined ? 
                            currentFrame.noagiPosition + (nextFrame.noagiPosition - currentFrame.noagiPosition) * clampedProgress : 0;
                        noagiMesh.position.y = targetY;
                    }
                }
                
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            createStars();
            init();
        });
    </script>
</body>
</html>
