<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGI Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        .stars {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        #canvas3d {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .header {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            opacity: 0;
            animation: headerAppear 1s 4s forwards;
            z-index: 100;
            pointer-events: none;
        }

        .header-content {
            display: inline-block;
            position: relative;
        }

        .header-noagi {
            font-size: 42px;
            font-weight: bold;
            color: #c0c0c0;
            opacity: 0.8;
            text-shadow: 0 0 10px rgba(192, 192, 192, 0.5);
        }

        .cross-line {
            position: absolute;
            top: 50%;
            left: -5%;
            width: 110%;
            height: 3px;
            background: linear-gradient(90deg, transparent, #ff4444, transparent);
            transform: translateY(-50%) rotate(-15deg);
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.7);
        }

        @keyframes headerAppear {
            0% { opacity: 0; transform: translateY(-20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .app-content {
            position: absolute;
            bottom: 80px;
            left: 0;
            width: 100%;
            text-align: center;
            opacity: 0;
            animation: contentAppear 1s 4.5s forwards;
            z-index: 100;
            pointer-events: none;
        }

        @keyframes contentAppear {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #c0c0c0;
            font-size: 18px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <div class="loading" id="loading">Загрузка анимации...</div>
    <canvas id="canvas3d"></canvas>
    
    <!-- Финальный заголовок -->
    <div class="header">
        <div class="header-content">
            <div class="header-noagi">AGI</div>
            <div class="cross-line"></div>
        </div>
    </div>
    
    <!-- Контент приложения -->
    <div class="app-content">
        <h2 style="color: #c0c0c0; margin-bottom: 10px;">Приложение AGI</h2>
        <p style="color: #a0a0a0;">Искусственный генеральный интеллект</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Создание звездного неба
        function createStars() {
            const starsContainer = document.getElementById('stars');
            const starsCount = 150;
            
            for (let i = 0; i < starsCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const size = Math.random() * 1.5 + 0.5;
                const delay = Math.random() * 4;
                
                star.style.left = `${x}%`;
                star.style.top = `${y}%`;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.animationDelay = `${delay}s`;
                
                starsContainer.appendChild(star);
            }
        }

        // OBJ данные перечеркнутой надписи
        const objData = `v  258.394409 0.000000 144.246750
v  260.075562 0.000000 139.854095
v  267.722046 0.000000 139.854095
v  269.348969 0.000000 144.246750
v  273.524719 0.000000 144.246750
v  270.867432 0.000000 137.196793
v  275.151642 0.000000 137.142563
v  276.507385 0.000000 140.559082
v  278.568146 0.000000 142.836761
v  281.008514 0.000000 143.975601
v  283.774261 0.000000 144.517914
v  286.377350 0.000000 144.409454
v  288.438110 0.000000 143.921371
v  290.824249 0.000000 142.945221
v  292.885010 0.000000 141.589462
v  292.993469 0.000000 137.196793
v  296.409973 0.000000 137.196793
v  296.355743 0.000000 144.246750
v  300.314575 0.000000 144.246750
v  300.260345 0.000000 137.196793
v  308.177979 0.000000 137.142563
v  308.177979 0.000000 133.834503
v  300.206116 0.000000 133.942963
v  300.314575 0.000000 124.940704
v  296.409973 0.000000 124.994934
v  296.464203 0.000000 133.942963
v  278.893524 0.000000 133.997192
v  279.381592 0.000000 131.339905
v  280.737366 0.000000 129.224915
v  282.852356 0.000000 128.194534
v  285.509644 0.000000 128.031845
v  287.733093 0.000000 129.062225
v  288.871948 0.000000 130.960297
v  292.668060 0.000000 130.309525
v  291.854614 0.000000 128.031845
v  289.956543 0.000000 126.025314
v  287.570404 0.000000 124.940704
v  284.587738 0.000000 124.615326
v  281.605042 0.000000 124.886475
v  278.839294 0.000000 126.133774
v  276.778534 0.000000 128.140305
v  275.477020 0.000000 131.014526
v  275.043182 0.000000 133.942963
v  269.403198 0.000000 133.942963
v  265.986664 0.000000 124.940704
v  261.648254 0.000000 125.049164
v  258.285950 0.000000 133.888733
v  248.470230 0.000000 133.997192
v  248.416000 0.000000 137.196793
v  256.930176 0.000000 137.251022
v  254.218658 0.000000 144.246750
v  262.190552 0.000000 133.888733
v  263.708984 0.000000 129.496063
v  265.444366 0.000000 133.997192
v  279.273132 0.000000 137.196793
v  289.088867 0.000000 137.196793
v  289.143097 0.000000 139.582932
v  286.431580 0.000000 140.992935
v  283.394653 0.000000 141.209854
v  281.062744 0.000000 140.125244

f 52 1 2
f 50 51 1
f 50 1 52
f 4 5 6
f 3 4 6
f 52 2 3
f 54 52 3
f 54 3 6
f 33 34 35
f 32 33 35
f 32 35 36
f 32 36 37
f 31 32 37
f 31 37 38
f 30 31 38
f 30 38 39
f 30 39 40
f 29 30 40
f 29 40 41
f 28 29 41
f 28 41 42
f 27 28 42
f 27 42 43
f 23 24 25
f 23 25 26
f 21 22 23
f 20 21 23
f 48 49 50
f 47 48 50
f 47 50 52
f 46 47 52
f 46 52 53
f 45 46 53
f 44 45 53
f 44 53 54
f 44 54 55
f 43 44 55
f 27 43 55
f 26 27 55
f 26 55 56
f 18 19 20
f 17 18 20
f 17 20 23
f 17 23 26
f 16 17 26
f 16 26 56
f 15 16 56
f 15 56 57
f 14 15 57
f 13 14 57
f 13 57 58
f 12 13 58
f 12 58 59
f 11 12 59
f 10 11 59
f 10 59 60
f 9 10 60
f 8 9 60
f 8 60 55
f 7 8 55
f 7 55 54
f 7 54 6`;

        function parseOBJ(text) {
            const vertices = [];
            const faces = [];
            
            const lines = text.split('\n');
            for (const line of lines) {
                const parts = line.trim().split(/\s+/);
                if (parts[0] === 'v') {
                    vertices.push([
                        parseFloat(parts[1]),
                        parseFloat(parts[2]), 
                        parseFloat(parts[3])
                    ]);
                } else if (parts[0] === 'f') {
                    const face = [];
                    for (let i = 1; i < parts.length; i++) {
                        const indices = parts[i].split('/');
                        face.push(parseInt(indices[0]) - 1);
                    }
                    faces.push(face);
                }
            }
            
            return { vertices, faces };
        }

        // Создание 3D сцены
        let scene, camera, renderer, skullMesh, noagiMesh;
        let skullTexture;

        function init() {
            // Сцена
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            // Камера
            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera.position.z = 8;

            // Рендерер
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas3d'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // Освещение
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xc0c0c0, 1);
            directionalLight1.position.set(2, 2, 2);
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0x808080, 0.5);
            directionalLight2.position.set(-2, -1, -1);
            scene.add(directionalLight2);

            // Создание мешей
            createMeshes();
            
            // Скрываем загрузку
            document.getElementById('loading').style.display = 'none';
            
            // Запуск анимации
            startAnimation();

            // Обработчик изменения размера
            window.addEventListener('resize', onWindowResize);
        }

        function createMeshes() {
            // Создание черепа из текстуры TERM.png
            const skullTextureLoader = new THREE.TextureLoader();
            
            // Создаем плоскость для черепа
            const skullGeometry = new THREE.PlaneGeometry(2, 3.12);
            const skullMaterial = new THREE.MeshBasicMaterial({ 
                map: skullTextureLoader.load('TERM.png'),
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            
            skullMesh = new THREE.Mesh(skullGeometry, skullMaterial);
            skullMesh.scale.set(0, 0, 0);
            scene.add(skullMesh);

            // Создание надписи AGI из OBJ данных
            const { vertices, faces } = parseOBJ(objData);
            
            // Вычисляем границы для смещения на 5%
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const vertex of vertices) {
                minX = Math.min(minX, vertex[0]);
                maxX = Math.max(maxX, vertex[0]);
                minY = Math.min(minY, vertex[2]); // Используем Z как Y в 2D
                maxY = Math.max(maxY, vertex[2]);
            }
            
            const width = maxX - minX;
            const height = maxY - minY;
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;

            // Создание геометрии из OBJ данных
            const noagiGeometry = new THREE.BufferGeometry();
            const positionArray = new Float32Array(vertices.length * 3);
            
            // Нормализуем координаты, центрируем и смещаем на 5%
            for (let i = 0; i < vertices.length; i++) {
                // Нормализация и центрирование
                const x = (vertices[i][0] - centerX) * 0.02;
                const y = (vertices[i][2] - centerY) * 0.02;
                
                // Смещение на 5% влево и вверх
                positionArray[i * 3] = x - width * 0.02 * 0.1;
                positionArray[i * 3 + 1] = y + height * 0.1;  //positionArray[i * 3 + 1] = y + height * 0.02 * 0.01;
                
                positionArray[i * 3 + 2] = vertices[i][1];
            }
            
            noagiGeometry.setAttribute('position', new THREE.BufferAttribute(positionArray, 3));
            
            // Создание индексов для faces
            const indices = [];
            for (const face of faces) {
                for (let i = 1; i < face.length - 1; i++) {
                    indices.push(face[0], face[i], face[i + 1]);
                }
            }
            noagiGeometry.setIndex(indices);
            noagiGeometry.computeVertexNormals();

            const noagiMaterial = new THREE.MeshPhongMaterial({
                color: 0xc0c0c0,
                shininess: 80,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });

            noagiMesh = new THREE.Mesh(noagiGeometry, noagiMaterial);
            noagiMesh.scale.set(22, 22, 22); // Начальный размер в 20 раз больше
            noagiMesh.rotation.x = Math.PI; // Поворот на 180 градусов по X
            scene.add(noagiMesh);
        }

        function startAnimation() {
            const timeline = [
                // 0-0.5s: Появление объектов
                { time: 0, skullScale: 1, noagiScale: 50, skullOpacity: 0, noagiOpacity: 0, noagiY: 0 },
                { time: 0.5, skullScale: 1, noagiScale: 50, skullOpacity: 1, noagiOpacity: 0.7, noagiY: 0 },
                
                // 0.5-3s: Масштабирование (3 секунды анимации)
                { time: 3, skullScale: 2, noagiScale: 0.91, skullOpacity: 1, noagiOpacity: 0.7, noagiY: 0 },
                
                // 3-4s: Исчезновение черепа и движение надписи вверх
                { time: 4, skullScale: 2, noagiScale: 0.91, skullOpacity: 0, noagiOpacity: 0.8, noagiY: 3 }
            ];

            let startTime = Date.now();

            function animate() {
                const currentTime = (Date.now() - startTime) / 1000;
                
                // Находим текущий и следующий ключевые кадры
                let currentFrame = timeline[0];
                let nextFrame = timeline[1];
                
                for (let i = 0; i < timeline.length - 1; i++) {
                    if (currentTime >= timeline[i].time && currentTime <= timeline[i + 1].time) {
                        currentFrame = timeline[i];
                        nextFrame = timeline[i + 1];
                        break;
                    }
                }
                
                // Интерполяция между кадрами
                const progress = Math.max(0, Math.min(1, 
                    (currentTime - currentFrame.time) / (nextFrame.time - currentFrame.time)
                ));
                
                // Применение анимации к черепу
                if (skullMesh) {
                    const skullScale = currentFrame.skullScale + (nextFrame.skullScale - currentFrame.skullScale) * progress;
                    skullMesh.scale.set(skullScale, skullScale, skullScale);
                    
                    const skullOpacity = currentFrame.skullOpacity + (nextFrame.skullOpacity - currentFrame.skullOpacity) * progress;
                    skullMesh.material.opacity = skullOpacity;
                }
                
                // Применение анимации к надписи
                if (noagiMesh) {
                    const noagiScale = currentFrame.noagiScale + (nextFrame.noagiScale - currentFrame.noagiScale) * progress;
                    noagiMesh.scale.set(noagiScale, noagiScale, noagiScale);
                    
                    const noagiOpacity = currentFrame.noagiOpacity + (nextFrame.noagiOpacity - currentFrame.noagiOpacity) * progress;
                    noagiMesh.material.opacity = noagiOpacity;
                    
                    const noagiY = currentFrame.noagiY + (nextFrame.noagiY - currentFrame.noagiY) * progress;
                    noagiMesh.position.y = noagiY;
                }
                
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', () => {
            createStars();
            // Даем время на создание звездного неба перед запуском 3D
            setTimeout(init, 100);
        });
    </script>
</body>
</html>
